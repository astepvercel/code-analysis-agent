/**
 * Tool Factory for creating sandbox-aware tools with minimal boilerplate.
 * Instead of manually wiring sandboxId through each tool definition
 * 
 * @example
 * const tools = createSandboxTools(sandboxId, [
 *   {
 *     name: "bash",
 *     description: "Execute a bash command",
 *     schema: toolSchemas.bash,
 *     step: runBash,
 *   },
 * ]);
 */

import { tool, type Tool } from "ai";
import { z } from "zod";

// A tool with any input/output types
type AnyTool = Tool<any, any>;

// A function that takes anything
type StepFunction = (params: any) => Promise<unknown>;

/**
 * Configuration for a single sandbox tool.
 */
export interface SandboxToolConfig {
  name: string;
  description: string;
  schema: z.ZodType; // The schema for the tool's input
  step: StepFunction; // The step function that executes the tool
}

/**
 * Creates a set of tools from tool configurations, automatically injecting sandboxId.
 *
 * This factory eliminates the boilerplate of manually threading sandboxId through
 * each tool definition. Each tool's step function will receive the sandboxId
 * automatically merged with the schema-validated input.
 *
 * @param sandboxId - The sandbox ID to inject into all tool executions
 * @param configs - Array of tool configurations
 * @returns Record of tool name to tool instance, ready for use with DurableAgent
 *
 * @example (autogenerated)
 * import { createSandboxTools, toolSchemas, toolDescriptions } from "./tool-factory";
 * import { runBash } from "../steps/bash";
 *
 * const tools = createSandboxTools(sandboxId, [
 *   {
 *     name: "bash",
 *     description: toolDescriptions.bash,
 *     schema: toolSchemas.bash,
 *     step: runBash,
 *   },
 * ]);
 */
export function createSandboxTools(
  sandboxId: string,
  configs: SandboxToolConfig[]
): Record<string, AnyTool> {
  const tools: Record<string, AnyTool> = {};

  for (const config of configs) {
    // schema validates input, sandboxId is injected
    const toolInstance = tool({
      description: config.description,
      inputSchema: config.schema as z.ZodObject<z.ZodRawShape>,
      execute: async (params) => {
        return config.step({ ...(params as Record<string, unknown>), sandboxId });
      },
    });
    tools[config.name] = toolInstance as AnyTool;
  }

  return tools;
}

/**
 * Pre-defined tool schemas for common sandbox operations.
 * Import the schemas you need and use them with createSandboxTools.
 */
export const toolSchemas = {
  bash: z.object({
    command: z.string().describe("The bash command to execute"),
  }),

  gitClone: z.object({
    repoUrl: z
      .string()
      .describe("GitHub repository URL (e.g., https://github.com/user/repo)"),
    destination: z.string().optional().describe("Directory name to clone into"),
  }),

  readFile: z.object({
    path: z.string().describe("Path to the file to read"),
  }),

  listFiles: z.object({
    path: z
      .string()
      .optional()
      .describe("Directory path (defaults to current dir)"),
    recursive: z.boolean().optional().describe("List recursively"),
    maxDepth: z
      .number()
      .optional()
      .describe("Max depth for recursive listing (default 3)"),
  }),

  searchFiles: z.object({
    pattern: z.string().describe("Search pattern (grep regex)"),
    path: z.string().default(".").describe("Directory to search in"),
    filePattern: z
      .string()
      .optional()
      .describe("File glob filter (e.g., '*.ts', '*.js')"),
  }),
};

/**
 * Tool descriptions optimized for AI understanding.
 */
export const toolDescriptions = {
  bash: "Execute any bash command in the sandbox. Use for operations not covered by other tools (find, wc, diff, npm, etc).",
  gitClone: "Clone a GitHub repository into the sandbox. Only call once per repo - it persists across messages.",
  readFile: "Read file contents from the sandbox filesystem.",
  listFiles: "List files and directories in the sandbox. Use to explore repository structure.",
  searchFiles: "Search for text patterns in files using grep. Use to find code patterns, imports, or specific text.",
};
